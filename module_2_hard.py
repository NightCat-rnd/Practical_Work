# Домашняя работа по уроку "Дополнительное практическое задание по модулю: "Основные операторы""
# Выполнил Андрей Чекунов
'''
Вы отправились в путешествие на необитаемый остров и конечно же в очередной вылазке в джунгли вы попали в ловушку местному племени
(да-да, классика "Индиана Джонса").
К вашему удивлению, в племени были неплохие математики и по совместительству фантазёры.
Вы поняли это, когда после долгих блужданий перед вами появились ворота (выход из ловушки) с двумя каменными вставками для чисел.
В первом поле камни с числом менялись постоянно (от 3 до 20) случайным образом, а второе было всегда пустым.

К вашему счастью рядом с менее успешными и уже неговорящими путешественниками находился папирус, где были написаны правила
для решения этого "ребуса". (Как жаль, что они поняли это так поздно :( ).

Во вторую вставку нужно было написать те пары чисел друг за другом, чтобы число из первой вставки
было кратно(делилось без остатка) сумме их значений.

Все пароли для чисел от 3 до 20 (для сверки):
3 - 12
4 - 13
5 - 1423
6 - 121524
7 - 162534
8 - 13172635
9 - 1218273645
10 - 141923283746
11 - 11029384756
12 - 12131511124210394857
13 - 112211310495867
14 - 1611325212343114105968
15 - 1214114232133124115106978
16 - 1317115262143531341251161079
17 - 11621531441351261171089
18 - 12151811724272163631545414513612711810
19 - 118217316415514613712811910
20 - 13141911923282183731746416515614713812911
'''

from random import randint

# Функция проверяет, дат ли в сумме первые два параметра третий
def multiplicity_check(int_a,int_b,int_number) :
    if int_number % (int_a+int_b) == 0 :
        return True
    else:
        return False

# Функция поиска пары значений для пароля. в качестве параметра передается значение для которого строится пароль
# Вызывает функцию выше, результат заносится в глобальный список, последовательно
def find_password_element (n):
    for i in range(1, ((n + 1) // 2)):              # перебираем младшую половину значений, т.к. в старшей пары значений
                                                    # будут такие же, только в обратном порядке (можно и не делать, крутить до n+1)
        for j in range(2, n + 1):
            if multiplicity_check(i, j, n) and i < j:    # вычисляем пару и смотрим что бы первое значение было меньше второго
                                                         # так исключаем повторения пар по значению, и пара не может быть из
                                                         # одинаковых чисел, по условию
                password_list.append(i)                 # добавляем пвру в список
                password_list.append(j)

# список правильных паролей для диапазона 3-20, нужен для функции тестирования
all_password = [12,13,1423,121524,162534,13172635,1218273645,141923283746,11029384756,12131511124210394857,
                112211310495867,1611325212343114105968,1214114232133124115106978,1317115262143531341251161079,
                11621531441351261171089,12151811724272163631545414513612711810,118217316415514613712811910,
                13141911923282183731746416515614713812911]

# Функция тестирования. цикл в диапазоне 3-20, с проверкой результата по контрольному списку паролей
def test_programm():
    for i in range(3,21) :
        password_list.clear()   #очистка генерируемого пароля перед рассчетом во избежании ошибок
        find_password_element(i)    # поиск пароля
        password_string = ''.join(map(str,password_list)) # преобразуем в строку
        if int(password_string) == all_password[i-3] :     # приводим к одному типу данных и сравниваем
            print(i,'Ok')
        else:
            print(f'Error number {i}')


password_list = []                            # создаем пустой список
number_random = randint(3,20)           # генерируем число, по условию оно в левой стороне
print(f'Число слева: {number_random}')
find_password_element(number_random)           # вычисляем пароль, он в глобальной переменной
print(''.join(map(str,password_list)))
print('\nПроверим все пароли от 3 до 20 по тестовой таблице из задания')
test_programm()                                 # делаем проверку алгоритма в соответствии с контрольным списком паролей

